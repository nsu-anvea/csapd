Библиотека OpenCV предоставляет набор функций, позволяющих
выполнять различные преобразования изображений, например, сглаживание,
морфологические преобразования (сужение и расширение), пороговые
преобразования и другие.

OpenCV (Open Source Computer Vision Library) — это открытая библиотека
для работы с алгоритмами компьютерного зрения,
машинным обучением и обработкой изображений.





capture.release(); // Освобождает ресурсы, связанные с захватом видео (например, закрывает доступ к камере).

cv::destroyAllWindows(); // Закрывает все окна, которые были открыты с помощью cv::imshow.





### Почему именно 33 мс?
FPS (frames per second) — это количество кадров, отображаемых за одну секунду. Для 30 FPS каждый кадр должен показываться в течение \( \frac{1}{30} \) секунды, то есть ~33,33 миллисекунды. 

Поэтому, если ты установишь задержку в 33 мс с помощью `cv::waitKey(33)`, программа приблизительно синхронизируется с частотой 30 FPS.

---

### Важные моменты:
1. **Задержка влияет только на отображение, но не на фактическую скорость обработки кадра.**
   - Если обработка кадра занимает больше времени (например, 50 мс), ты не достигнешь 30 FPS, даже если задержка равна 33 мс.
   - В таком случае реальная частота кадров будет ограничена скоростью обработки.

2. **Точность задержки не идеальна.**
   - `cv::waitKey` не гарантирует абсолютно точное время задержки. Например, операционная система или другие процессы могут немного замедлить выполнение программы.

3. **Реальная частота кадров зависит от оборудования.**
   - Если камера работает с частотой 15 FPS, ты не сможешь получить 30 FPS на выходе, даже с правильной задержкой.

---

### Итог:
Да, задержка в 33 мс приближает тебя к 30 FPS, но для точного достижения этой частоты обработки важно учитывать:
- Сколько времени занимает обработка одного кадра.
- Ограничения оборудования (камеры, процессора).





### Что может происходить?
Есть несколько возможных причин:

#### 1. **`cv::waitKey(33)` добавляет задержку**
   - Ты используешь `cv::waitKey(33)` (или другой вызов с задержкой). Это означает, что цикл может намеренно ждать, чтобы синхронизироваться с заданным FPS.
   - Если `waitKey` вызывается с задержкой, её нужно учитывать в общем времени цикла.

#### 2. **Операции вне замеров**
   - Есть дополнительные операции в цикле, которые не попадают в твои замеры:
     - Логика измерения времени.
     - Обновление счётчиков (`frameCount`, `fpsCount`).
     - Вызов `std::cout` для вывода данных на экран.  
       **Примечание:** `std::cout` может быть довольно медленным, особенно при частых вызовах.

#### 3. **Проблемы с точностью измерений**
   - Твои замеры (`st3`, `st1`, `st2`) покрывают только определённые участки кода, но они не захватывают весь цикл. Например:
     - Код между замерами (например, обработка клавиш с `cv::waitKey`).
     - Операции на уровне операционной системы (например, управление буферами камеры).

#### 4. **Системные задержки**
   - Операционная система может "замораживать" выполнение программы на короткое время:
     - Переключение между процессами.
     - Обработка аппаратных событий (например, доступ к камере).
     - Потоки данных из камеры.

---

### Что делать, чтобы понять точную причину?
1. **Добавь замеры всего цикла**
   Сейчас ты измеряешь время цикла только в конце, но не охватываешь его полностью. Добавь замеры вокруг всех операций:
   ```cpp
   auto startCycle = std::chrono::high_resolution_clock::now();
   // Весь цикл: захват, преобразование, показ, ожидание
   auto endCycle = std::chrono::high_resolution_clock::now();
   std::chrono::duration<double, std::milli> fullCycleTime = endCycle - startCycle;
   std::cout << "Время полного цикла: " << fullCycleTime.count() << " мс" << std::endl;
   ```

2. **Проверь влияние `cv::waitKey`**
   Замерь отдельно, сколько времени занимает `cv::waitKey`:
   ```cpp
   auto waitStart = std::chrono::high_resolution_clock::now();
   cv::waitKey(33);
   auto waitEnd = std::chrono::high_resolution_clock::now();
   std::chrono::duration<double, std::milli> waitTime = waitEnd - waitStart;
   std::cout << "Время ожидания waitKey: " << waitTime.count() << " мс" << std::endl;
   ```

3. **Уменьши использование `std::cout`**
   - Если выводить данные слишком часто, это может добавить существенные задержки. Попробуй собирать данные и выводить их только раз в несколько итераций.